<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>チケットメーカー</title>
    <style>
@font-face {
    font-family: 'ITC Avant Garde Gothic Std Extra Light';
    src: url('fonts/ITC Avant Garde Gothic Std Extra Light.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
}
@font-face {
    font-family: 'AR ADGothicJP';
    src: url('fonts/jadhei01m.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
}
@font-face {
    font-family: 'KozGoPr6N';
    src: url('fonts/KozGoPr6N-Medium.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
    
}
body { 
    font-family: "KozGoPr6N", "AR ADGothicJP", "YuGothic", "Meiryo", sans-serif; 
            margin: 0; 
            padding: 20px; 
            position: relative; 
            background-color: #FFF4F6; 
            color: #F676A6; 
        }
        #previewSizeButtons button, .input-group button { 
            font-family: "KozGoPr6N", "AR ADGothicJP", "YuGothic", "Meiryo", sans-serif; 
        }
        #languageSelector { 
            font-family: "KozGoPr6N", "AR ADGothicJP", "YuGothic", "Meiryo", sans-serif; 
        }
        /* 其他 CSS 不變 */
    </style>
    <!-- Google AdSense 和 qrcode.js 腳本保持不變 -->
</head>
<body>
    <!-- body 內容保持不變 -->
    <script>
        const canvas = document.getElementById('ticketCanvas');
        const ctx = canvas.getContext('2d');
        let qrImage = null;
        let previewScale = 0.5;

        // 尺寸參數 (單位: mm -> 像素)
        const baseWidthMm = 150;
        const baseHeightMm = 65;
        const bleedMm = 3;
        const baseWidth300 = Math.round(baseWidthMm * 300 / 25.4);
        const baseHeight300 = Math.round(baseHeightMm * 300 / 25.4);
        const bleedWidth300 = Math.round((baseWidthMm + 2 * bleedMm) * 300 / 25.4);
        const bleedHeight300 = Math.round((baseHeightMm + 2 * bleedMm) * 300 / 25.4);
        const baseWidth70 = Math.round(baseWidthMm * 70 / 25.4);
        const baseHeight70 = Math.round(baseHeightMm * 70 / 25.4);
        const bleedWidth70 = Math.round((baseWidthMm + 2 * bleedMm) * 70 / 25.4);
        const bleedHeight70 = Math.round((baseHeightMm + 2 * bleedMm) * 70 / 25.4);

        // 字體定義
        const fontAvantGarde = 'ITC Avant Garde Gothic Std Extra Light, sans-serif'; 矩形1文字
        const fontKozGo = 'KozGoPr6N, YuGothic, sans-serif'; // 中文字
        const fontARADGothic = 'AR ADGothicJP, MS PGothic, sans-serif'; // 英文、數字、符號

        // 語言翻譯數據（保持不變）
        const translations = {/* 原有 translations 內容 */};

        // 精確字距與行距繪製函數
        function drawTextWithSpacingAndLeading(lines, x, y, font, fontSize, letterSpacing, lineHeight, color, align = 'left', alternateFont = null, dpi = 300) {
            const ptToPx = dpi / 72;
            ctx.fillStyle = color;
            ctx.textAlign = align;

            lines.forEach((line, index) => {
                let currentX = x;
                const lineY = y + (index * lineHeight * ptToPx);

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const isAlternate = alternateFont && /[A-Za-z0-9①❘－]/.test(char);
                    ctx.font = `${fontSize * ptToPx}px ${isAlternate ? alternateFont : font}`;
                    ctx.fillText(char, currentX, lineY);
                    const charWidth = ctx.measureText(char).width;
                    currentX += charWidth + (letterSpacing * ptToPx / 1000);
                }
            });
        }

        function drawTicket(dpi = 300) {
            const useBleed = document.getElementById('bleedOption').checked;
            const width = useBleed ? (dpi === 300 ? bleedWidth300 : bleedWidth70) : (dpi === 300 ? baseWidth300 : baseWidth70);
            const height = useBleed ? (dpi === 300 ? bleedHeight300 : bleedHeight70) : (dpi === 300 ? baseHeight300 : baseHeight70);
            const mmToPx = dpi / 25.4;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = (width * previewScale) + 'px';
            canvas.style.height = (height * previewScale) + 'px';

            ctx.clearRect(0, 0, width, height);

            // 背景顏色
            ctx.fillStyle = document.getElementById('bgColor').value;
            ctx.fillRect(0, 0, width, height);

            // 背景文字與陰影
            const bgText = document.getElementById('bgText').value || "AKB48";
            const bgTextX = parseFloat(document.getElementById('bgTextX').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
            const bgTextY = parseFloat(document.getElementById('bgTextY').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
            const bgTextSpacing = parseFloat(document.getElementById('bgTextSpacing').value);
            const bgTextLineHeight = parseFloat(document.getElementById('bgTextLineHeight').value);
            const bgTextSize = parseFloat(document.getElementById('bgTextSize').value);
            ctx.font = `${bgTextSize * (dpi / 72)}px ${fontAvantGarde}`;

            const singleCharWidth = ctx.measureText(bgText.charAt(0)).width;
            const textWidth = ctx.measureText(bgText).width;
            const repeatGapX = textWidth + (bgTextSpacing * (dpi / 72) / 1000);
            const repeatGapY = bgTextLineHeight * (dpi / 72);

            ctx.globalAlpha = parseFloat(document.getElementById('bgShadowOpacity').value);
            ctx.fillStyle = document.getElementById('bgShadowColor').value;
            ctx.shadowColor = document.getElementById('bgShadowColor').value;
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = parseFloat(document.getElementById('bgShadowX').value) * mmToPx;
            ctx.shadowOffsetY = parseFloat(document.getElementById('bgShadowY').value) * mmToPx;
            let rowIndex = 0;
            for (let y = bgTextY; y < height; y += repeatGapY) {
                const rowOffset = rowIndex * singleCharWidth;
                for (let x = bgTextX + rowOffset; x < width; x += repeatGapX) {
                    ctx.fillText(bgText, x, y);
                }
                rowIndex++;
            }

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.fillStyle = document.getElementById('bgTextColor').value;
            rowIndex = 0;
            for (let y = bgTextY; y < height; y += repeatGapY) {
                const rowOffset = rowIndex * singleCharWidth;
                for (let x = bgTextX + rowOffset; x < width; x += repeatGapX) {
                    ctx.fillText(bgText, x, y);
                }
                rowIndex++;
            }

            // 矩形1
            ctx.fillStyle = document.getElementById('rect1Color').value;
            ctx.fillRect(8 * mmToPx + (useBleed ? bleedMm * mmToPx : 0), 0 + (useBleed ? bleedMm * mmToPx : 0), 25 * mmToPx, 35 * mmToPx);
            const rect1Color = document.getElementById('rect1TextColor').value;
            const rect1Line1X = parseFloat(document.getElementById('rect1Line1X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
            const rect1Line1Y = parseFloat(document.getElementById('rect1Line1Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
            const rect1Spacing = parseFloat(document.getElementById('rect1Spacing').value);
            const rect1Size = parseFloat(document.getElementById('rect1Size').value);
            const rect1Line2X = parseFloat(document.getElementById('rect1Line2X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
            const rect1Line2Y = parseFloat(document.getElementById('rect1Line2Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
            const rect1Line2Spacing = parseFloat(document.getElementById('rect1Line2Spacing').value);
            const rect1Line2Size = parseFloat(document.getElementById('rect1Line2Size').value);
            drawTextWithSpacingAndLeading([document.getElementById('rect1Line1').value], rect1Line1X, rect1Line1Y, fontAvantGarde, rect1Size, rect1Spacing, 0, rect1Color, 'center', null, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('rect1Line2').value], rect1Line2X, rect1Line2Y, fontAvantGarde, rect1Line2Size, rect1Line2Spacing, 0, rect1Color, 'center', null, dpi);

            // 其他文字
            const textColor = document.getElementById('textColor').value;
            drawTextWithSpacingAndLeading([document.getElementById('text2').value], parseFloat(document.getElementById('text2X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text2Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text2Size').value), parseFloat(document.getElementById('text2Spacing').value), 0, textColor, 'left', fontARADGothic, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('text3Line1').value], parseFloat(document.getElementById('text3Line1X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text3Line1Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text3Size').value), parseFloat(document.getElementById('text3Spacing').value), 0, textColor, 'left', fontARADGothic, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('text3Line2').value], parseFloat(document.getElementById('text3Line2X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text3Line2Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text3Line2Size').value), parseFloat(document.getElementById('text3Line2Spacing').value), 0, textColor, 'left', fontARADGothic, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('text4Line1').value, document.getElementById('text4Line2').value], parseFloat(document.getElementById('text4Line1X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text4Line1Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text4Size').value), parseFloat(document.getElementById('text4Spacing').value), parseFloat(document.getElementById('text4LineHeight').value), textColor, 'left', fontARADGothic, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('text5').value], parseFloat(document.getElementById('text5X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text5Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text5Size').value), parseFloat(document.getElementById('text5Spacing').value), 27, textColor, 'left', fontARADGothic, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('text6').value], parseFloat(document.getElementById('text6X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text6Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text6Size').value), parseFloat(document.getElementById('text6Spacing').value), 27, textColor, 'left', fontARADGothic, dpi);

            // 矩形9
            ctx.fillStyle = document.getElementById('rect9Color').value;
            ctx.fillRect(0 + (useBleed ? bleedMm * mmToPx : 0), 58 * mmToPx + (useBleed ? bleedMm * mmToPx : 0), 150 * mmToPx, 7 * mmToPx);

            // 文字10-12
            const footerColor = document.getElementById('footerTextColor').value;
            drawTextWithSpacingAndLeading([document.getElementById('text10').value], parseFloat(document.getElementById('text10X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text10Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text10Size').value), parseFloat(document.getElementById('text10Spacing').value), 0, footerColor, 'left', fontARADGothic, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('text11').value], parseFloat(document.getElementById('text11X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text11Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text11Size').value), parseFloat(document.getElementById('text11Spacing').value), 0, footerColor, 'left', fontARADGothic, dpi);
            drawTextWithSpacingAndLeading([document.getElementById('text12').value], parseFloat(document.getElementById('text12X').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), parseFloat(document.getElementById('text12Y').value) * mmToPx + (useBleed ? bleedMm * mmToPx : 0), fontKozGo, parseFloat(document.getElementById('text12Size').value), parseFloat(document.getElementById('text12Spacing').value), 0, footerColor, 'left', fontARADGothic, dpi);

            // QR Code 正方形
            if (document.getElementById('showQR').checked) {
                ctx.fillStyle = document.getElementById('qrSquareColor').value;
                const qrX = width - 8.5 * mmToPx - 23 * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
                const qrY = 23 * mmToPx + (useBleed ? bleedMm * mmToPx : 0);
                const qrSize = 23 * mmToPx;
                ctx.fillRect(qrX, qrY, qrSize, qrSize);

                const qrText = document.getElementById('qrCodeText').value;
                if (qrImage) {
                    ctx.drawImage(qrImage, qrX, qrY, qrSize, qrSize);
                } else if (qrText) {
                    const qrCanvas = document.createElement('canvas');
                    const qrContext = qrCanvas.getContext('2d');
                    qrCanvas.width = qrSize;
                    qrCanvas.height = qrSize;
                    const qrcode = new QRCode(qrCanvas, {
                        text: qrText,
                        width: qrSize,
                        height: qrSize,
                        colorDark: "#000000",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.H
                    });
                    ctx.drawImage(qrCanvas, qrX, qrY, qrSize, qrSize);
                }
            }
        }

        function setPreviewScale(scale) {
            previewScale = scale;
            drawTicket(300);
        }

        function downloadTicket(dpi) {
            drawTicket(dpi);
            const link = document.createElement('a');
            link.download = `ticket_${dpi}dpi${document.getElementById('bleedOption').checked ? '_with_bleed' : ''}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
            drawTicket(300);
        }

        document.getElementById('qrCodeInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    qrImage = new Image();
                    qrImage.src = event.target.result;
                    qrImage.onload = () => drawTicket(300);
                };
                reader.readAsDataURL(file);
            }
        });

        document.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', () => drawTicket(300));
        });

        function toggleAdvancedMode() {
            const groups = document.querySelectorAll('.advanced-mode');
            groups.forEach(group => group.classList.toggle('active'));
            const btn = document.getElementById('advancedModeBtn');
            const lang = document.documentElement.lang;
            btn.textContent = btn.textContent === translations[lang]['advancedMode'] ? 
                (lang === 'ja' ? '詳細設定を閉じる' : lang === 'zh-TW' ? '關閉進階模式' : 'Close Advanced Mode') : 
                translations[lang]['advancedMode'];
        }

        function changeLanguage(lang) {
            document.documentElement.lang = lang;
            document.title = translations[lang]['title'];
            document.querySelector('#canvasContainer h1').textContent = translations[lang]['preview'];
            document.querySelector('#controlsContainer h1').textContent = translations[lang]['custom'];
            
            document.querySelectorAll('[data-key]').forEach(element => {
                const key = element.getAttribute('data-key');
                if (translations[lang][key]) {
                    if (element.tagName === 'LABEL') {
                        element.childNodes[0].textContent = translations[lang][key] + ': ';
                    } else if (element.tagName === 'BUTTON') {
                        element.textContent = translations[lang][key];
                    } else if (element.classList.contains('note')) {
                        element.textContent = translations[lang][key];
                    }
                }
            });

            document.querySelector('#qrCodeText').placeholder = translations[lang]['qrPlaceholder'];
        }

        drawTicket(300);
    </script>
</body>
</html>
